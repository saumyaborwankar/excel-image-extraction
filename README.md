# Excel Image & Overlay Extraction to SVG

Complete solution for extracting images and shape overlays from Excel files and generating editable SVG outputs.

---

## üéØ Problem Statement

You have Excel files with:
- **Images** embedded in cells
- **Shapes/drawings** overlaid on top of those images (circles, rectangles, text boxes, etc.)

**Requirements:**
1. Extract the images
2. Detect which shapes are overlaying which images
3. Create composite images that show the base image + overlays
4. **Keep the base image and overlays separate** so they can be extracted/edited later

---

## üìã How It Works: Step-by-Step

### **Step 1: Read the Excel File**

```python
wb = load_workbook(file_path, data_only=True)
```

We use `openpyxl` to open `sample.xlsx` and read its contents.

---

### **Step 2: Extract Shape Information from Excel XML**

**Why XML?** Excel files (.xlsx) are actually ZIP archives containing XML files. Shape/drawing information is stored in `xl/drawings/drawing*.xml`.

```python
def extract_shapes_from_excel(file_path, sheet_name):
    with zipfile.ZipFile(file_path, "r") as zip_ref:
        # Find drawing XML files
        drawing_files = [f for f in zip_ref.namelist()
                        if 'xl/drawings/drawing' in f]
```

For each shape, we extract:
- **Name** (e.g., "Shape 3", "Shape 4")
- **Geometry type** (ellipse, rect, roundRect, triangle)
- **Position** (which cell it starts in + pixel offset)
- **Size** (width and height in EMUs - Excel Metric Units)
- **Colors**:
  - Fill color (RGB hex like `#FF0000`)
  - Fill transparency/alpha
  - Outline/stroke color
  - Outline width
- **Text content** (if the shape contains text)
- **Font size** (stored in hundredths of points, e.g., 1400 = 14pt)

**Example shape data:**
```python
{
    'name': 'Shape 4',
    'geometry': 'rect',
    'fill_color': None,  # No fill
    'outline_color': '#FF0000',  # Red border
    'outline_width': 4,
    'text': 'Saumya',
    'font_size_pt': 14.0,
    'from_col': 3, 'from_row': 1,  # Starts at column D, row 2
    'from_col_off': 123456,  # EMU offset from cell corner
    'from_row_off': 789012,
    'to_col': 5, 'to_row': 3,  # Ends at column F, row 4
    'width_emu': 952500,  # Width in EMUs
    'height_emu': 419100   # Height in EMUs
}
```

---

### **Step 3: Convert Excel Coordinates to Pixels**

Excel uses:
- **Cell-based positioning** (column D, row 2)
- **EMU offsets** (English Metric Units: 914,400 EMU = 1 inch)

We need **absolute pixel positions** to render overlays correctly.

```python
def emu_to_pixels(emu):
    return emu / 9525  # Conversion factor

def cell_to_pixels(ws, row, col):
    # Calculate pixel position by summing column widths and row heights
    x = sum(column_widths) * 7  # Excel unit conversion
    y = sum(row_heights) * 1.33
    return x, y
```

**For each shape:**
```python
# Get cell position
cell_x, cell_y = cell_to_pixels(ws, from_row + 1, from_col + 1)

# Add offset from cell corner
abs_x = cell_x + emu_to_pixels(from_col_off)
abs_y = cell_y + emu_to_pixels(from_row_off)

# Calculate size
width_px = emu_to_pixels(width_emu)
height_px = emu_to_pixels(height_emu)
```

Now we know: **"Shape 4 is at pixel (375, 140) with size 100x44"**

---

### **Step 4: Extract Images from Excel**

```python
for image in ws._images:
    # Get image position (same cell-based + EMU system)
    # Get image bytes
    img_bytes = image._data()

    # Save as PNG
    with open(img_path, 'wb') as f:
        f.write(img_bytes)

    # Load for processing
    pil_image = Image.open(io.BytesIO(img_bytes))
```

We extract:
- Image position (absolute x, y in pixels)
- Image size (calculated width/height from Excel cells)
- **Actual image dimensions** (1024x1024 pixels for example)
- Image data as PIL Image object

**Key insight:** Excel's calculated size (191x191px) ‚â† actual image size (1024x1024px)

This means we need a **scaling factor**: `scale_x = 1024/191 = 5.361`

---

### **Step 5: Detect Overlays**

For each image, check if shapes overlay it:

```python
def rectangles_overlap(rect1, rect2):
    # Check if two rectangles intersect
    x1, y1, w1, h1 = rect1
    x2, y2, w2, h2 = rect2

    return not (
        x1 + w1 <= x2  # rect1 is left of rect2
        or x2 + w2 <= x1  # rect2 is left of rect1
        or y1 + h1 <= y2  # rect1 is above rect2
        or y2 + h2 <= y1  # rect2 is above rect1
    )
```

**Example:**
```
Image at (329, 7) size 191x191
Shape at (375, 140) size 100x44

Do they overlap? YES
375 is between 329 and 520 (329+191) ‚úì
140 is between 7 and 198 (7+191) ‚úì
```

---

### **Step 6: Generate SVG Output (THE KEY PART)**

This is where the magic happens! Instead of just creating a flat image, we create an **SVG file** that keeps everything separate.

#### 6a. **Embed Base Image as Base64**

```python
def image_to_base64(pil_image):
    buffered = io.BytesIO()
    pil_image.save(buffered, format="PNG")
    img_bytes = buffered.getvalue()
    return base64.b64encode(img_bytes).decode('utf-8')
```

This converts the PNG to a text string like:
```
iVBORw0KGgoAAAANSUhEUgAABAAAAAQACAMAAABIw9ux...
```

#### 6b. **Create SVG Structure**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     width="1024" height="1024">

  <!-- BASE IMAGE (embedded) -->
  <image id="base-image"
         xlink:href="data:image/png;base64,iVBORw0KG..."
         width="1024" height="1024"
         x="0" y="0"/>

  <!-- OVERLAYS (editable shapes) -->
  <g id="overlays">

    <!-- Shape 1: Circle with red border -->
    <g id="Shape 3" class="shape-overlay" data-geometry="ellipse">
      <ellipse cx="503.5" cy="478.5" rx="278.5" ry="313.5"
               fill="none"
               stroke="#FF0000" stroke-width="4"/>
    </g>

    <!-- Shape 2: Text box -->
    <g id="Shape 4" class="shape-overlay" data-geometry="rect">
      <rect x="246" y="716" width="536" height="235"
            fill="none" stroke="none"/>
      <text x="514.0" y="833.5"
            font-size="75px"
            font-family="Arial, sans-serif"
            text-anchor="middle"
            fill="#000000">Saumya</text>
    </g>

  </g>
</svg>
```

#### 6c. **Apply Scaling to Shapes**

Remember: Excel calculated 191x191, actual image is 1024x1024

```python
scale_x = 1024 / 191 = 5.361
scale_y = 1024 / 191 = 5.361

# Scale shape position
rel_x = (shape_x - image_x) * scale_x
rel_y = (shape_y - image_y) * scale_y

# Scale shape size
width_scaled = shape_width * scale_x
height_scaled = shape_height * scale_y

# Scale font size
scaled_font_size = 14pt * 5.361 = 75px
```

**Result:** Shapes are positioned correctly on the high-resolution image!

---

### **Step 7: Also Create JPG Preview**

For quick viewing, we also rasterize to JPG:

```python
# Create composite using PIL
composite = base_img.convert("RGBA")
draw = ImageDraw.Draw(composite)

# Draw each shape
for shape in shape_overlays:
    if shape['geometry'] == 'ellipse':
        draw.ellipse([x, y, x2, y2], fill=fill, outline=stroke)
    elif shape['geometry'] == 'rect':
        draw.rectangle([x, y, x2, y2], fill=fill, outline=stroke)
    # ... etc

# Save as JPG
composite_rgb = composite.convert("RGB")
composite_rgb.save(path, "JPEG", quality=95)
```

---

## üìÅ Output Files Created

### Main Outputs

```
images_with_overlays/
‚îú‚îÄ‚îÄ D1-F10_with_overlays.svg  (912 KB)
‚îÇ   ‚îú‚îÄ‚îÄ Base image (embedded as base64)
‚îÇ   ‚îî‚îÄ‚îÄ Overlays (editable SVG shapes)
‚îÇ
‚îî‚îÄ‚îÄ D1-F10_with_overlays.jpg  (387 KB)
    ‚îî‚îÄ‚îÄ Flattened preview image
```

### Separated Layers (via utility scripts)

```
separated_layers/
‚îú‚îÄ‚îÄ D1-F10_with_overlays_base_image.png  (683 KB)
‚îÇ   ‚îî‚îÄ‚îÄ Extracted PNG (decoded from base64)
‚îÇ
‚îú‚îÄ‚îÄ D1-F10_with_overlays_overlays_only.svg  (781 B)
‚îÇ   ‚îî‚îÄ‚îÄ Just the shapes, no base image
‚îÇ
‚îú‚îÄ‚îÄ D1-F10_with_overlays_shape_Shape 3.svg  (438 B)
‚îÇ   ‚îî‚îÄ‚îÄ Individual circle shape
‚îÇ
‚îî‚îÄ‚îÄ D1-F10_with_overlays_shape_Shape 4.svg  (585 B)
    ‚îî‚îÄ‚îÄ Individual text box shape
```

---

## üîÑ How Components Stay Separate

### In the SVG:

1. **Base Image Element:**
   ```xml
   <image id="base-image" xlink:href="data:image/png;base64,..."/>
   ```
   - Self-contained (base64 encoded)
   - Can be extracted by decoding base64

2. **Shape Elements:**
   ```xml
   <ellipse cx="503.5" cy="478.5" rx="278.5" ry="313.5"
            fill="none" stroke="#FF0000"/>
   ```
   - Native SVG geometry
   - Fully editable (change colors, positions, sizes)
   - Can be removed/added

3. **Grouped Separately:**
   ```xml
   <g id="overlays">
     <!-- All shapes here -->
   </g>
   ```

---

## üí° Why This Approach Works

### ‚úÖ **Separation**
- Base image: `<image>` element with base64 data
- Overlays: `<ellipse>`, `<rect>`, `<text>` elements
- Can extract/edit independently

### ‚úÖ **Editability**
- Open SVG in Inkscape/Illustrator
- Change shape colors: edit `fill="#FF0000"`
- Move shapes: edit `x`, `y`, `cx`, `cy`
- Edit text: change text content
- Add/remove shapes: add/remove `<g>` elements

### ‚úÖ **Extractability**

**Get base image:**
```python
# Parse SVG
tree = ET.parse('file.svg')
image = tree.find('.//image[@id="base-image"]')

# Extract base64
href = image.get('{http://www.w3.org/1999/xlink}href')
base64_data = href.split(',', 1)[1]

# Decode to PNG
png_bytes = base64.b64decode(base64_data)
```

**Get shapes:**
```python
overlays = tree.find('.//g[@id="overlays"]')
shapes = overlays.findall('.//g[@class="shape-overlay"]')

for shape in shapes:
    shape_id = shape.get('id')  # "Shape 3"
    geometry = shape.get('data-geometry')  # "ellipse"
    # ... extract properties
```

### ‚úÖ **Standards-Based**
- Uses standard SVG 1.1 spec
- Works with all SVG tools
- Can convert to other formats (PDF, PNG, etc.) while preserving structure

---

## üé¨ Complete Flow Diagram

```
Excel File (sample.xlsx)
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ Images (embedded PNGs)
    ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ Extract to memory
    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ Drawings XML (xl/drawings/drawing*.xml)
          ‚îî‚îÄ‚îÄ‚îÄ Parse to get shape data

                    ‚Üì

Calculate Positions & Detect Overlays
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ Convert Excel coordinates ‚Üí Pixels
    ‚îú‚îÄ‚îÄ‚îÄ Check which shapes overlay which images
    ‚îî‚îÄ‚îÄ‚îÄ Calculate scaling factors

                    ‚Üì

Generate SVG
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ Convert base image ‚Üí Base64
    ‚îú‚îÄ‚îÄ‚îÄ Create <image> element with base64
    ‚îú‚îÄ‚îÄ‚îÄ Create <ellipse>, <rect>, <text> for each shape
    ‚îî‚îÄ‚îÄ‚îÄ Apply scaling to positions/sizes

                    ‚Üì

Save Outputs
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ SVG (editable, separate components)
    ‚îî‚îÄ‚îÄ‚îÄ JPG (flattened preview)

                    ‚Üì

Utilities (optional)
    ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ Extract base image (decode base64 ‚Üí PNG)
    ‚îú‚îÄ‚îÄ‚îÄ Extract shapes (create individual SVGs)
    ‚îî‚îÄ‚îÄ‚îÄ Create overlays-only SVG (remove base image)
```

---

## üß™ Example: What Happens to "Shape 4"

1. **Excel:** Shape at cell D2, offset 123456 EMU, size 952500x419100 EMU
2. **Convert:** Position (375, 140) px, size (100, 44) px
3. **Detect:** Overlays image at (329, 7) size 191x191
4. **Scale:**
   - Relative position: (375-329, 140-7) = (46, 133)
   - Scaled: (46√ó5.361, 133√ó5.361) = (246, 716)
   - Scaled size: (100√ó5.361, 44√ó5.361) = (536, 235)
   - Font: 14pt √ó 5.361 = 75px
5. **SVG:**
   ```xml
   <rect x="246" y="716" width="536" height="235"/>
   <text x="514" y="833.5" font-size="75px">Saumya</text>
   ```
6. **Result:** Perfectly positioned text box on 1024x1024 image

---

## üöÄ Usage

### Installation

```bash
# Create virtual environment
python3 -m venv venv

# Activate virtual environment
source venv/bin/activate  # On macOS/Linux
# or
venv\Scripts\activate  # On Windows

# Install dependencies
pip install openpyxl Pillow
```

### Run Main Script

```bash
# Generate SVG and JPG files
python3 extract.py
```

**Output:**
- `images_with_positions/*.png` - Individual extracted images
- `images_with_overlays/*.svg` - SVG files with embedded images + overlays
- `images_with_overlays/*.jpg` - Rasterized preview files

### Extract Components (Optional)

```bash
# View SVG component details
python3 extract_svg_components.py

# Separate into individual layers
python3 separate_svg_layers.py
```

**Output:**
- `separated_layers/*_base_image.png` - Extracted base images
- `separated_layers/*_overlays_only.svg` - Overlays without base image
- `separated_layers/*_shape_*.svg` - Individual shape SVGs

---

## üìÇ Project Structure

```
attemptv2/
‚îú‚îÄ‚îÄ extract.py                          # Main script
‚îú‚îÄ‚îÄ extract_svg_components.py       # Utility: inspect SVG structure
‚îú‚îÄ‚îÄ separate_svg_layers.py          # Utility: separate layers
‚îú‚îÄ‚îÄ sample.xlsx                     # Input Excel file
‚îú‚îÄ‚îÄ README.md                       # This file
‚îú‚îÄ‚îÄ SVG_SOLUTION.md                 # Technical documentation
‚îÇ
‚îú‚îÄ‚îÄ images_with_positions/          # Extracted individual images
‚îú‚îÄ‚îÄ images_with_overlays/           # SVG + JPG composites
‚îî‚îÄ‚îÄ separated_layers/               # Separated components
```

---

## üîë Key Features

- ‚úÖ **Separation** - Base image and overlays remain completely independent
- ‚úÖ **Editability** - All overlays can be edited in vector editors
- ‚úÖ **Scalability** - SVG is resolution-independent
- ‚úÖ **Extractability** - Components can be extracted programmatically
- ‚úÖ **Standards-based** - Uses standard SVG format, compatible with all tools
- ‚úÖ **Self-contained** - No external dependencies (base64 embedding)
- ‚úÖ **Correct scaling** - Shapes positioned accurately on high-res images
- ‚úÖ **All properties preserved** - Colors, fonts, transparency, geometry

---

## üìñ Documentation

- **README.md** (this file) - Complete walkthrough and usage guide
- **SVG_SOLUTION.md** - Technical documentation and API reference

---

## üéØ Result

You now have:
- ‚úÖ SVG files with **embedded base images** (base64)
- ‚úÖ **Editable shape overlays** as native SVG elements
- ‚úÖ **Complete separation** - can extract/edit components independently
- ‚úÖ **Correct scaling** - shapes positioned accurately on high-res images
- ‚úÖ **All properties preserved** - colors, fonts, transparency, geometry
- ‚úÖ **Standard format** - works with all SVG tools
- ‚úÖ **Self-contained** - no external dependencies

The goal of **keeping base images and overlays separate even after export** is fully achieved! üéâ

---

## üìù License

This project is provided as-is for educational and commercial use.

---

## ü§ù Contributing

Feel free to submit issues, fork the repository, and create pull requests for any improvements.
